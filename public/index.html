<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Skintelli Antioxidant Score</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 680px; margin: 40px auto; }
    label { display: block; margin-bottom: .5rem; }
    #out { font-size: 1.4rem; margin-top: 1rem; }
  </style>

  <!-- 1) Pyodide (load Python in WASM) -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
  <!-- 2) OpenCV.js (no async so it's ready when our module runs) -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <h2>Skintelli Antioxidant Score</h2>
  <label>Choose card photo:
    <input type="file" id="file" accept="image/*">
  </label>
  <div id="out">‚è≥ loading engine‚Ä¶</div>

  <script type="module">
  // simple updater for status text
  const show = msg => document.getElementById('out').textContent = msg;

  try {
    // 1) Bootstrap Pyodide
    const py = await loadPyodide({
      indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/"
    });
    await py.loadPackage(['numpy','pandas','scikit-image']);

    // 2) Wait for OpenCV.js runtime to initialize
    await new Promise(resolve => { cv['onRuntimeInitialized'] = resolve; });

    // 3) Load your CSV lookup table into Pyodide's FS
    const csvText = await fetch('trainingLab.csv').then(r => r.text());
    py.FS.writeFile('/tmp/training.csv', csvText);

    // 4) Inject the Python scorer code
    await py.runPythonAsync(`
import numpy as np, pandas as pd, cv2 as cv
from skimage.color import rgb2lab, deltaE_ciede2000 as dE

# load lookup
_table = pd.read_csv('/tmp/training.csv')
LAB   = _table[['L','a','b']].values
SCORE = _table['score'].values

# constants
W,H = 1000,500
BOX,PAD = 0.06, 0.08
PX,SY,CY = 0.92, 0.20, 0.60

def delta(l1, l2): return float(dE(l1[None], l2[None])[0])

def warp_card(img):
    h,w = img.shape[:2]
    gray = cv.GaussianBlur(cv.cvtColor(img, cv.COLOR_BGR2GRAY), (5,5), 0)
    cnts,_ = cv.findContours(cv.Canny(gray,50,150),
                             cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    quad = max((c for c in cnts if 0.25*w*h < cv.contourArea(c) < 0.9*w*h),
               key=cv.contourArea, default=None)
    if quad is None: return cv.resize(img, (W,H))
    peri = cv.arcLength(quad, True)
    approx = cv.approxPolyDP(quad, 0.02*peri, True)
    if len(approx) != 4: return cv.resize(img, (W,H))
    pts = np.squeeze(approx).astype(np.float32)
    s = pts.sum(1); d = np.diff(pts,axis=1).ravel()
    ordered = np.array([pts[np.argmin(s)], pts[np.argmin(d)],
                        pts[np.argmax(s)], pts[np.argmax(d)]], np.float32)
    dst = np.array([[0,0],[W-1,0],[W-1,H-1],[0,H-1]], np.float32)
    M = cv.getPerspectiveTransform(ordered, dst)
    return cv.warpPerspective(img, M, (W,H))

def crop_sq(img, cx, cy, side_pct):
    h,w = img.shape[:2]
    side = int(side_pct * w)
    x0 = max(0, int(cx*w) - side//2)
    y0 = max(0, int(cy*h) - side//2)
    return img[y0:y0+side, x0:x0+side]

def med_lab(roi):
    lab = rgb2lab(cv.cvtColor(roi, cv.COLOR_BGR2RGB))
    return np.median(lab.reshape(-1,3), axis=0)

def score_array(bgr):
    card = warp_card(bgr)
    printed = [ med_lab(crop_sq(card, 0.05 + i*0.13, 0.75, BOX)) for i in range(6) ]
    sample  = med_lab(crop_sq(card, PX, SY, PAD))
    control = med_lab(crop_sq(card, PX, CY, PAD))
    wb = np.array([95-control[0], -control[1], -control[2]])
    sample_c = sample + wb
    printed_c = [p + wb for p in printed]
    dists = np.array([delta(sample_c, row) for row in LAB])
    if dists.min() <= 3:
        raw = SCORE[dists.argmin()]
    else:
        w = np.exp(-np.array([delta(sample_c, p) for p in printed_c]) / 2.5)
        raw = (w * np.arange(6)).sum() / w.sum()
    return round(np.clip(raw, 0, 5) * 4) / 4

def score_from_js(buf, h, w):
    arr = np.frombuffer(buf, dtype=np.uint8).reshape(h, w, 3).copy()
    return score_array(arr)
`);

    // 5) Ready for user
    show('‚úÖ Python & OpenCV ready ‚Äì pick a photo.');

    // 6) Handle file selection
    document.getElementById('file').addEventListener('change', async e => {
      const file = e.target.files[0];
      if (!file) return;
      show('üñºÔ∏è decoding‚Ä¶');

      // decode with OpenCV.js
      const buffer = await file.arrayBuffer();
      const u8 = new Uint8Array(buffer);
      const mat = cv.matFromArray(u8, 1);
      const img = cv.imdecode(mat, cv.IMREAD_COLOR);
      mat.delete();

      const { rows: h, cols: w } = img;
      const data = new Uint8Array(img.data);
      img.delete();

      // pass to Pyodide
      py.globals.set('buf_js', data);
      py.globals.set('h_js', h);
      py.globals.set('w_js', w);

      const score = py.runPython('score_from_js(buf_js, int(h_js), int(w_js))');
      show('‚úÖ Antioxidant Score: ' + score);
    });
  }
  catch (err) {
    console.error(err);
    show('‚ö†Ô∏è ' + err);
  }
  </script>
</body>
</html>
