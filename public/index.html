<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Card Capture Overlay</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden;font-family:sans-serif;}
    #videoElement{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);} /* mirror */
    #overlayCanvas{position:absolute;inset:0;pointer-events:none;}
    #statusText{position:absolute;top:8px;left:50%;transform:translateX(-50%);padding:6px 12px;border-radius:8px;background:rgba(0,0,0,.65);color:#fff;font-size:15px;white-space:nowrap;}
    #captureButton{position:absolute;bottom:24px;left:50%;transform:translateX(-50%);padding:14px 30px;border:none;border-radius:26px;font-size:18px;font-weight:600;background:rgba(255,255,255,.85);color:#000;backdrop-filter:blur(4px);}  
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline></video>
  <canvas id="overlayCanvas"></canvas>
  <div id="statusText">Initializing…</div>
  <button id="captureButton" disabled>Capture</button>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
  const video  = document.getElementById('videoElement');
  const canvas = document.getElementById('overlayCanvas');
  const ctx    = canvas.getContext('2d');
  const statusText = document.getElementById('statusText');
  const captureBtn = document.getElementById('captureButton');

  /* ------ constants ------ */
  const CARD_ASPECT = 1280/726;          //≈1.763 – taken from sample image
  const GUIDE_MARGIN = 0.08;             // % of minor viewport edge kept as margin around guide
  const BRIGHT_THRESH = 50;              // luma threshold
  const ALIGN_POS_TOL = 0.10;            // 10 % positional tolerance
  const ALIGN_SIZE_TOL = 0.12;           // 12 % size tolerance
  const ALIGN_ASPECT_TOL = 0.10;         // 10 % aspect-ratio tolerance

  /* ------ camera ------ */
  async function setupCamera(){
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
    video.srcObject = stream;
    return new Promise(res=>video.onloadedmetadata=()=>res());
  }

  /* ------ opencv ready ------ */
  let cvReady=false;
  cv['onRuntimeInitialized']=()=>{cvReady=true;};

  /* ------ helpers ------ */
  function frameBrightness(grayMat){
    return cv.mean(grayMat)[0]; // gray – R==G==B
  }

  function getBoundingBox(quad){
    const xs = quad.map(p=>p.x), ys = quad.map(p=>p.y);
    return {x:Math.min(...xs), y:Math.min(...ys), w:Math.max(...xs)-Math.min(...xs), h:Math.max(...ys)-Math.min(...ys)};
  }

  function sameShape(bb){
    // compare bbox to guideRect for alignment
    const dx = Math.abs(bb.x - guideRect.x);
    const dy = Math.abs(bb.y - guideRect.y);
    const dw = Math.abs(bb.w - guideRect.w);
    const dh = Math.abs(bb.h - guideRect.h);
    const posOk = dx < guideRect.w*ALIGN_POS_TOL && dy < guideRect.h*ALIGN_POS_TOL;
    const sizeOk = dw < guideRect.w*ALIGN_SIZE_TOL && dh < guideRect.h*ALIGN_SIZE_TOL;
    const aspectOk = Math.abs(bb.w/bb.h - CARD_ASPECT) < CARD_ASPECT*ALIGN_ASPECT_TOL;
    return posOk && sizeOk && aspectOk;
  }

  function drawGuide(color){
    ctx.lineWidth = 4;
    ctx.strokeStyle = color;
    ctx.strokeRect(guideRect.x,guideRect.y,guideRect.w,guideRect.h);

    // rule-of-thirds grid inside
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = color + '66'; // translucent
    ctx.beginPath();
    for(const t of [1/3,2/3]){
      ctx.moveTo(guideRect.x + guideRect.w*t, guideRect.y);
      ctx.lineTo(guideRect.x + guideRect.w*t, guideRect.y+guideRect.h);
      ctx.moveTo(guideRect.x, guideRect.y + guideRect.h*t);
      ctx.lineTo(guideRect.x+guideRect.w, guideRect.y + guideRect.h*t);
    }
    ctx.stroke();
  }

  /* ------ main loop ------ */
  let guideRect = null; // will compute when video size known

  function processFrame(){
    if(!cvReady){return requestAnimationFrame(processFrame);}    
    const w = video.videoWidth;
    const h = video.videoHeight;
    if(!w||!h){return requestAnimationFrame(processFrame);}    
    canvas.width = w; canvas.height = h;

    if(!guideRect){
      // compute guide dimensions maintaining aspect and margins
      let targetW = w*(1-2*GUIDE_MARGIN);
      let targetH = targetW/CARD_ASPECT;
      if(targetH>h*(1-2*GUIDE_MARGIN)){
        targetH = h*(1-2*GUIDE_MARGIN);
        targetW = targetH*CARD_ASPECT;
      }
      guideRect = {
        x:(w-targetW)/2,
        y:(h-targetH)/2,
        w:targetW,
        h:targetH
      };
    }

    // draw video frame into canvas (allows color checks)
    ctx.drawImage(video,0,0,w,h);

    // brightness
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
    const bright = frameBrightness(gray);
    const tooDark = bright < BRIGHT_THRESH;

    // detect card (largest quad) if bright enough
    let aligned = false;
    if(!tooDark){
      let blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
      let edged=new cv.Mat(); cv.Canny(blur,edged,60,160);
      let contours=new cv.MatVector(); let hierarchy=new cv.Mat();
      cv.findContours(edged,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);
      let maxArea=0, bestQuad=null;
      for(let i=0;i<contours.size();i++){
        const cnt=contours.get(i);
        const peri=cv.arcLength(cnt,true);
        const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true);
        if(approx.rows===4){
          const area=cv.contourArea(approx);
          if(area>maxArea){maxArea=area; bestQuad=Array.from({length:4},(_,k)=>({x:approx.data32S[k*2],y:approx.data32S[k*2+1]}));}
        }
      }
      if(bestQuad && maxArea> (w*h*0.05)){
        const bb = getBoundingBox(bestQuad);
        aligned = sameShape(bb);
      }
      // clean mats
      blur.delete(); edged.delete(); contours.delete(); hierarchy.delete();
    }

    // overlay
    ctx.clearRect(0,0,w,h);
    const guideColor = aligned && !tooDark ? '#00FF00' : '#FF0000';
    drawGuide(guideColor);

    if(tooDark){
      statusText.textContent = 'Too dark – add light';
      captureBtn.disabled = true;
    }else if(aligned){
      statusText.textContent = 'Perfect – tap Capture';
      captureBtn.disabled = false;
      captureBtn.onclick = ()=>saveImage();
    }else{
      statusText.textContent = 'Align card to guide';
      captureBtn.disabled = true;
    }

    // cleanup mats
    src.delete(); gray.delete();

    requestAnimationFrame(processFrame);
  }

  /* ------ capture using guide rectangle ------ */
  function saveImage(){
    const {x,y,w:hx,h:hy} = guideRect; // renaming variables
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = hx; // hx is actually guideRect.w
    tempCanvas.height = hy; // hy is guideRect.h
    const tctx = tempCanvas.getContext('2d');
    tctx.drawImage(video, x, y, hx, hy, 0, 0, hx, hy);
    const link = document.createElement('a');
    link.download = 'card.jpg';
    link.href = tempCanvas.toDataURL('image/jpeg',0.9);
    link.click();
  }

  (async()=>{
    try{
      await setupCamera();
      statusText.textContent = 'Align card to guide';
      requestAnimationFrame(processFrame);
    }catch(e){
      statusText.textContent='Camera permission needed';
      console.error(e);
    }
  })();
</script>
</body>
</html>