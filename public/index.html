<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Skintelli Card Capture</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- ─── CDN LOADS ─── -->
  <!-- jScanify: tiny rectangle detector (~120 KB gz) -->
  <script src="https://cdn.jsdelivr.net/npm/jscanify@1.0.4/dist/jscanify.min.js"></script>
  <!-- Tesseract.js: fallback OCR (~180 KB gz) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    /* ─── Base Layout ─── */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: -apple-system, Roboto, Helvetica, Arial, sans-serif;
    }
    /* The container for live camera */
    #wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* Video preview and overlay canvas fill the wrapper */
    #video, #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    /* The “Tap to enable camera” banner */
    #msg {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-size: 16px;
      border-radius: 8px;
      z-index: 20;
      text-align: center;
    }
    /* Hint text appears below the guides */
    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 15px;
      text-align: center;
      z-index: 20;
    }
    /* Shutter button in the bottom center */
    #shutter {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 4px solid #fff;
      background: rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.35;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 20;
    }
    #shutter::after {
      content: '';
      width: 54px;
      height: 54px;
      border-radius: 50%;
      background: #fff;
    }
    #shutter.ready {
      opacity: 1;
      pointer-events: auto;
    }
    #shutter.ready::after {
      background: #0f0;
    }
    /* Full‐screen “fatal” overlay if camera fails */
    #fatal {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-size: 17px;
      text-align: center;
      padding: 24px;
      z-index: 30;
    }
    /* Preview screen (hidden until shutter tap) */
    #preview {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
      z-index: 25;
    }
    #preview img {
      max-width: 96%;
      max-height: 80%;
      border: 4px solid #fff;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    .ctrls {
      display: flex;
      gap: 20px;
    }
    .ctrls button {
      padding: 12px 26px;
      font-size: 16px;
      border: none;
      border-radius: 40px;
      background: #fff;
    }
  </style>
</head>

<body>
  <!-- ─── Wrapper for Live Camera + Overlays ─── -->
  <div id="wrapper">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div id="msg">Tap anywhere to enable camera</div>
    <div id="hint"></div>
    <button id="shutter" aria-label="Shutter"></button>
    <div id="fatal"></div>
  </div>

  <!-- ─── Preview / Download Stage ─── -->
  <div id="preview">
    <img id="captured" alt="Captured image">
    <div class="ctrls">
      <button id="download">Download</button>
      <button id="retake">Retake</button>
    </div>
  </div>

  <script>
    // ─── Configuration ───
    const CARD_RATIO   = 1280 / 726;     // Skintelli card is landscape 1280×726
    const PADDING      = 0.08;           // 8% margin on each side of the guides
    const MIN_COVER    = 0.90;           // Rectangle must fill ≥90% of the guide
    const OCR_PATTERN  = /SKINTELLI/i;   // Look for “SKINTELLI”
    const OCR_DEBOUNCE = 800;            // ms between OCR checks
    const OUTPUT_WIDTH = 1280;           // JPEG output width

    // ─── DOM Elements ───
    const wrapper  = document.getElementById('wrapper');
    const videoEl  = document.getElementById('video');
    const canvas   = document.getElementById('overlay');
    const ctx      = canvas.getContext('2d');
    const msg      = document.getElementById('msg');
    const hint     = document.getElementById('hint');
    const shutter  = document.getElementById('shutter');
    const fatal    = document.getElementById('fatal');
    const preview  = document.getElementById('preview');
    const captured = document.getElementById('captured');
    const download = document.getElementById('download');
    const retake   = document.getElementById('retake');

    // ─── State Variables ───
    let guideRect    = { x:0, y:0, w:0, h:0 };
    let ready        = false;
    let lastOCR      = 0;
    let tesseract    = null;                 // Lazy‐init for Tesseract.js
    const offscreen  = document.createElement('canvas');

    // ─── Build horizontal guide once video metadata is ready ───
    function buildGuide(videoWidth, videoHeight) {
      const maxW = videoWidth * (1 - PADDING * 2);
      let gw = maxW, gh = gw / CARD_RATIO;
      if (gh > videoHeight * (1 - PADDING * 2)) {
        gh = videoHeight * (1 - PADDING * 2);
        gw = gh * CARD_RATIO;
      }
      guideRect = {
        x: (videoWidth - gw) / 2,
        y: (videoHeight - gh) / 2,
        w: gw,
        h: gh
      };
      // Also size the offscreen canvas for processing
      offscreen.width  = videoWidth;
      offscreen.height = videoHeight;
      // And the overlay canvas:
      canvas.width     = videoWidth;
      canvas.height    = videoHeight;

      // Immediately draw the white guides before detection runs
      drawGuides(false);
    }

    // ─── Draw four “L”‐corner guides (white if !isGreen, green if isGreen) ───
    function drawGuides(isGreen) {
      const { x, y, w, h } = guideRect;
      const L = 40; // bracket length

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 6;
      ctx.strokeStyle = isGreen ? '#0f0' : '#fff';

      // Top-left
      ctx.beginPath();
      ctx.moveTo(x, y + L); ctx.lineTo(x, y); ctx.lineTo(x + L, y); ctx.stroke();

      // Top-right
      ctx.beginPath();
      ctx.moveTo(x + w - L, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + L); ctx.stroke();

      // Bottom-right
      ctx.beginPath();
      ctx.moveTo(x + w, y + h - L); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - L, y + h); ctx.stroke();

      // Bottom-left
      ctx.beginPath();
      ctx.moveTo(x + L, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - L); ctx.stroke();

      // Rule-of-thirds lines
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      for (let i = 1; i < 3; i++) {
        // Vertical third
        ctx.beginPath();
        ctx.moveTo(x + (w * i)/3, y);
        ctx.lineTo(x + (w * i)/3, y + h);
        ctx.stroke();
        // Horizontal third
        ctx.beginPath();
        ctx.moveTo(x, y + (h * i)/3);
        ctx.lineTo(x + w, y + (h * i)/3);
        ctx.stroke();
      }

      // Position the hint 20px below bottom edge of box
      hint.style.top = `${y + h + 20}px`;
    }

    // ─── OCR helper: try TextDetector if available, else Tesseract fallback ───
    async function detectTextSKINTELLI(blob) {
      if ('TextDetector' in window) {
        try {
          const detector = new TextDetector();
          const bmp      = await createImageBitmap(blob);
          const results  = await detector.detect(bmp);
          bmp.close();
          return results.some(r => /SKINTELLI/i.test(r.rawValue));
        } catch (e) {
          // If native OCR fails, fallback below
        }
      }
      // Tesseract fallback (180 KB gz)
      if (!tesseract) {
        tesseract = Tesseract.createWorker();
        await tesseract.load();
        await tesseract.loadLanguage('eng');
        await tesseract.initialize('eng');
      }
      const { data: { text } } = await tesseract.recognize(blob);
      return /SKINTELLI/i.test(text);
    }

    // ─── Called on user tap to start camera ───
    async function enableCamera() {
      // Remove both tap listeners so it only runs once
      wrapper.removeEventListener('click', enableCamera);
      wrapper.removeEventListener('touchstart', enableCamera);

      // Immediately hide the “Tap anywhere…” message
      msg.style.display = 'none';

      // Request camera
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        videoEl.srcObject = stream;
        // Must call play() inside this user-gesture to suppress iOS ▶︎ icon
        await videoEl.play();
      } catch (err) {
        fatal.textContent = 'Camera error:\n' + (err.message || err.name);
        fatal.style.display = 'flex';
        return;
      }

      // Wait for metadata to know resolution
      await new Promise(r => { videoEl.onloadedmetadata = r; });

      // Build guides now that we know video size
      buildGuide(videoEl.videoWidth, videoEl.videoHeight);

      // Start main detection loop
      requestAnimationFrame(detectLoop);
    }

    // ─── Main detection loop: rectangle → OCR → color guides → enable shutter ───
    async function detectLoop() {
      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(videoEl, 0, 0);

      const { x, y, w, h } = guideRect;
      // Get ROI image data
      const roiData = offCtx.getImageData(x, y, w, h);

      // 1) jScanify rectangle detection
      const quads = window.jscanify.detect(roiData);
      let rectOK = false;
      if (quads.length) {
        const q = quads[0];
        // Compute width/height in ROI space
        const bw = Math.hypot(q[1].x - q[0].x, q[1].y - q[0].y);
        const bh = Math.hypot(q[3].x - q[0].x, q[3].y - q[0].y);
        if (bw / w >= MIN_COVER && bh / h >= MIN_COVER) {
          rectOK = true;
        }
      }

      // 2) If rectangle present, run OCR (debounce by OCR_DEBOUNCE ms)
      let ocrOK = false;
      const now = Date.now();
      if (rectOK && now - lastOCR > OCR_DEBOUNCE) {
        lastOCR = now;
        // Export ROI to JPEG Blob for OCR
        const blob = await new Promise(r => offscreen.toBlob(r, 'image/jpeg', 0.6));
        ocrOK = await detectTextSKINTELLI(blob);
      }

      ready = rectOK && ocrOK;

      // 3) Draw guides (green if ready, else white)
      drawGuides(ready);

      // 4) Update hint text & shutter state
      hint.textContent = ready
        ? 'Hold steady and press shutter'
        : rectOK
          ? 'Reading card…'
          : 'Move card fully inside brackets';
      shutter.classList.toggle('ready', ready);

      requestAnimationFrame(detectLoop);
    }

    // ─── Shutter click: crop + scale + show preview ───
    shutter.addEventListener('click', () => {
      if (!ready) return;

      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(videoEl, 0, 0);

      const { x, y, w, h } = guideRect;
      const outCanvas = document.createElement('canvas');
      outCanvas.width  = OUTPUT_WIDTH;
      outCanvas.height = Math.round(OUTPUT_WIDTH / CARD_RATIO);
      const outCtx = outCanvas.getContext('2d');
      outCtx.drawImage(
        offscreen,
        x, y, w, h,
        0, 0,
        outCanvas.width, outCanvas.height
      );

      const jpegUrl = outCanvas.toDataURL('image/jpeg', 0.9);
      // Switch to preview
      wrapper.style.display = 'none';
      preview.style.display = 'flex';
      captured.src = jpegUrl;

      // Download button
      download.onclick = () => {
        const a = document.createElement('a');
        a.href = jpegUrl;
        a.download = 'skintelli_card.jpg';
        a.click();
      };
      // Retake button
      retake.onclick = () => {
        preview.style.display = 'none';
        wrapper.style.display = 'block';
        ready = false;
        hint.textContent = '';
      };
    });

    // ─── Bind first‐tap listeners to #wrapper ───
    wrapper.addEventListener('touchstart', enableCamera, { once: true });
    wrapper.addEventListener('click', enableCamera, { once: true });
  </script>
</body>
</html>
