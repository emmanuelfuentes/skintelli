<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Card Capture Guide</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #container{position:relative;width:100%;height:100%}
  video,canvas{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}
  canvas{pointer-events:none;z-index:10}
  #msg{position:absolute;top:16px;left:50%;transform:translateX(-50%);padding:6px 12px;border-radius:8px;
       background:rgba(0,0,0,.6);color:#fff;font-size:15px;z-index:20}
  #capture{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);padding:14px 36px;font-size:18px;
           border:none;border-radius:48px;background:#fff;color:#000;z-index:20;opacity:.35;pointer-events:none;
           transition:opacity .2s}
  #capture.enabled{opacity:1;pointer-events:auto}
</style>
</head>
<body>
<div id="container">
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>
  <div id="msg">Opening camera…</div>
  <button id="capture">Capture</button>
</div>

<!-- OpenCV (≈ 1 MB) – loads asynchronously -->
<script async src="https://docs.opencv.org/4.x/opencv.js"
        onload="window._cvReady = true"></script>

<script type="module">
/* ------------  SETTINGS  ------------ */
const CARD_RATIO   = 1280/726;   // your sample image ≈ 1.7627
const TOLERANCE    = 0.10;       // ±10 % size/ratio margin
const BRIGHT_MIN   = 60;         // mean brightness threshold 0-255
const MARGIN       = 0.10;       // 10 % safe border around screen
const DEST_W       = 800;        // output image width (px)

/* ------------  DOM refs  ------------ */
const video   = document.getElementById('video');
const canvas  = document.getElementById('overlay');
const ctx     = canvas.getContext('2d');
const msgBar  = document.getElementById('msg');
const snapBtn = document.getElementById('capture');

/* ------------  globals  ------------ */
let ready2snap = false;
let lastQuad   = null;           // 4-pt card corner list for capture
let _cvReady   = false;

/* wait until cv & cam are ready ..................................... */
const waitForCV = () => new Promise(r => {
  if (window._cvReady) return r();
  const i = setInterval(()=>{ if (window._cvReady){clearInterval(i);r();}},50);
});

const start = async () => {
  await waitForCV();
  _cvReady = true;

  /* open rear camera */
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{facingMode:{ideal:'environment'}}
  });
  video.srcObject = stream;

  /* once we know video dimensions, match canvas */
  video.onloadedmetadata = () => {
    canvas.width  = video.videoWidth;
    canvas.height = video.videoHeight;
    msgBar.textContent = 'Align card to guide';
    requestAnimationFrame(processFrame);
  };
};

/* ------------  Main per-frame loop  ------------ */
const off = document.createElement('canvas');  // off-screen for OpenCV
const processFrame = () => {
  if (!_cvReady || video.readyState < 2) return requestAnimationFrame(processFrame);

  /* ensure off-screen canvas matches video */
  off.width  = video.videoWidth;
  off.height = video.videoHeight;
  const octx = off.getContext('2d');
  octx.drawImage(video,0,0);

  /* ---- brightness check (downsampled) ---- */
  const small = octx.getImageData(0,0,8,8).data;     // 64 pixels
  let lum = 0;
  for(let i=0;i<small.length;i+=4){
    lum += (small[i]+small[i+1]+small[i+2])/3;
  }
  const brightOK = (lum/16) > BRIGHT_MIN;            // average brightness

  /* ---- contour detection ---- */
  let alignedOK = false;
  lastQuad = null;

  try{
    const src = cv.imread(off);                      // Mat from canvas
    cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(src, src, new cv.Size(5,5), 0);
    cv.Canny(src, src, 50, 150);

    const contours = new cv.MatVector(), hierarchy = new cv.Mat();
    cv.findContours(src, contours, hierarchy,
                    cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0, best = null;
    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const area = cv.contourArea(cnt);
      if(area > maxArea){ maxArea = area; best = cnt; }
    }

    if (best){
      const peri = cv.arcLength(best,true);
      const approx = new cv.Mat();
      cv.approxPolyDP(best, approx, 0.02*peri, true);

      if (approx.rows === 4){   // we found a quad
        const pts = [];
        for(let i=0;i<4;i++){
          pts.push({x:approx.intAt(i,0), y:approx.intAt(i,1)});
        }
        /* order points tl,tr,br,bl */
        pts.sort((a,b)=>a.x+b.y - (b.x+a.y));  // rough sort
        const [tl, br] = [pts[0], pts[3]];
        const rest = [pts[1], pts[2]];
        rest.sort((a,b)=>a.x-b.x);
        const [tr, bl] = rest;
        const quad = [tl,tr,br,bl];

        /* bounding box & ratio */
        const w = Math.hypot(tr.x-tl.x, tr.y-tl.y);
        const h = Math.hypot(bl.x-tl.x, bl.y-tl.y);
        const ratioOK = Math.abs(w/h - CARD_RATIO)/CARD_RATIO < TOLERANCE;

        /* size (fills guide) check */
        const screenArea = canvas.width*canvas.height;
        const areaOK = (maxArea/screenArea) > (1-(MARGIN*2))**2 * 0.6; // ~60 % of guide

        if(ratioOK && areaOK){
          alignedOK = true;
          lastQuad = quad;
        }
      }
      approx.delete();
    }
    src.delete(); contours.delete(); hierarchy.delete();
  }catch(e){ console.error(e); }

  ready2snap = brightOK && alignedOK;
  drawGuide(ready2snap);

  msgBar.textContent = brightOK
    ? (ready2snap ? 'Perfect – tap Capture' : 'Align card to guide')
    : 'Too dark – add light';

  snapBtn.classList.toggle('enabled', ready2snap);
  requestAnimationFrame(processFrame);
};

/* ------------  Draw red/green guide ------------ */
const drawGuide = good => {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  const availW = W*(1-MARGIN*2);
  let gw = availW, gh = gw / CARD_RATIO;
  if (gh > H*(1-MARGIN*2)){
    gh = H*(1-MARGIN*2); gw = gh*CARD_RATIO;
  }
  const x = (W-gw)/2, y=(H-gh)/2;

  ctx.lineWidth = 4;
  ctx.strokeStyle = good ? '#00ff00' : '#ff0000';
  ctx.strokeRect(x,y,gw,gh);

  /* rule-of-thirds */
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  for(let i=1;i<3;i++){
    ctx.beginPath();
    ctx.moveTo(x+gw*i/3, y);      ctx.lineTo(x+gw*i/3, y+gh); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y+gh*i/3);      ctx.lineTo(x+gw, y+gh*i/3); ctx.stroke();
  }
};

/* ------------  Capture button ------------ */
snapBtn.addEventListener('click', ()=>{
  if(!ready2snap || !lastQuad) return;

  /* perspective-correct crop with OpenCV */
  const src = cv.imread(off);
  const dsize = new cv.Size(DEST_W, Math.round(DEST_W/CARD_RATIO));
  const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,
      lastQuad.flatMap(p=>[p.x,p.y]));
  const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,
      [0,0,dsize.width,0,dsize.width,dsize.height,0,dsize.height]);
  const M = cv.getPerspectiveTransform(srcTri, dstTri);
  const dst = new cv.Mat();
  cv.warpPerspective(src, dst, M, dsize,
                     cv.INTER_LINEAR, cv.BORDER_CONSTANT);

  const outCanvas = document.createElement('canvas');
  outCanvas.width = dsize.width; outCanvas.height = dsize.height;
  cv.imshow(outCanvas,dst);

  /* download */
  const link = document.createElement('a');
  link.href = outCanvas.toDataURL('image/jpeg',0.9);
  link.download = 'card.jpg';
  link.click();

  src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();
});

/* kick things off */
start();
</script>
</body>
</html>
