<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Skintelli Card Capture (Exact 3.5×2 in Rectangle)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- ─── CDN LIBRARIES ─── -->
  <!-- jScanify: rectangle detection (~120 KB gz) -->
  <script src="https://cdn.jsdelivr.net/npm/jscanify@1.0.4/dist/jscanify.min.js"></script>
  <!-- Tesseract.js: fallback OCR (~180 KB gz) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    /* ─── Base Layout ─── */
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
      font-family: -apple-system, Roboto, Helvetica, Arial, sans-serif;
    }
    #wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
    }
    video {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    /* Hide iOS white ▶︎ icon */
    video::-webkit-media-controls-start-playback-button {
      display: none !important;
      -webkit-appearance: none;
    }

    /* ─── “Tap anywhere to enable camera” Banner ─── */
    #msg {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-size: 16px;
      border-radius: 8px;
      z-index: 20;
      text-align: center;
      pointer-events: none;
    }

    /* ─── Centered Guide Container ───
       We will set its width/height via JavaScript to be:
       width = 84% of viewport width (84vw),
       height = (84vw) ÷ 1.75
    */
    #guide {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 20;
      /* width + height assigned by JavaScript */
    }

    /* ─── Four Thick “L” Corners Inside #guide ─── */
    .corner {
      position: absolute;
      width: 40px;
      height: 40px;
    }
    .corner .inner {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    /* Top-Left */
    .corner.tl {
      top: 0;
      left: 0;
    }
    .corner.tl .inner {
      border-left: 8px solid #fff;
      border-top:  8px solid #fff;
    }
    /* Top-Right */
    .corner.tr {
      top: 0;
      right: 0;
    }
    .corner.tr .inner {
      border-right: 8px solid #fff;
      border-top:   8px solid #fff;
    }
    /* Bottom-Left */
    .corner.bl {
      bottom: 0;
      left:   0;
    }
    .corner.bl .inner {
      border-left:   8px solid #fff;
      border-bottom: 8px solid #fff;
    }
    /* Bottom-Right */
    .corner.br {
      bottom:  0;
      right:   0;
    }
    .corner.br .inner {
      border-right:  8px solid #fff;
      border-bottom: 8px solid #fff;
    }
    /* When cardDetected=true, flip corners to green */
    .corner.ready .inner {
      border-color: #0f0 !important;
    }

    /* ─── Hint Text: Positioned 20px below #guide ─── */
    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 15px;
      text-align: center;
      z-index: 20;
      pointer-events: none;
    }

    /* ─── Shutter Button (Bottom Center) ─── */
    #shutter {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 4px solid #fff;
      background: rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #shutter::after {
      content: '';
      width: 54px;
      height: 54px;
      border-radius: 50%;
      background: #fff;         /* white circle by default */
    }
    #shutter.ready::after {
      background: #0f0;         /* green when cardDetected */
    }

    /* ─── Fatal Error Overlay ─── */
    #fatal {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-size: 17px;
      text-align: center;
      padding: 24px;
      z-index: 30;
    }

    /* ─── Preview Stage ─── */
    #preview {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000;
      z-index: 25;
    }
    #preview img {
      max-width: 96%;
      max-height: 80%;
      border: 4px solid #fff;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    .ctrls {
      display: flex;
      gap: 20px;
    }
    .ctrls button {
      padding: 12px 26px;
      font-size: 16px;
      border: none;
      border-radius: 40px;
      background: #fff;
    }
  </style>
</head>
<body>
  <!-- ─── LIVE CAMERA + OVERLAYS ─── -->
  <div id="wrapper">
    <video id="video" playsinline muted></video>

    <!--
      JavaScript will set #guide’s width to 84vw and height to (84vw ÷ 1.75).
      The four corners (tl, tr, bl, br) sit at its four corners.
    -->
    <div id="guide">
      <div id="corner_tl" class="corner tl"><div class="inner"></div></div>
      <div id="corner_tr" class="corner tr"><div class="inner"></div></div>
      <div id="corner_bl" class="corner bl"><div class="inner"></div></div>
      <div id="corner_br" class="corner br"><div class="inner"></div></div>
    </div>

    <div id="msg">Tap anywhere to enable camera</div>
    <div id="hint"></div>
    <button id="shutter" aria-label="Shutter"></button>
    <div id="fatal"></div>
  </div>

  <!-- ─── CAPTURE PREVIEW ─── -->
  <div id="preview">
    <img id="captured" alt="Captured image" />
    <div class="ctrls">
      <button id="download">Download</button>
      <button id="retake">Retake</button>
    </div>
  </div>

  <script>
    // ─── Configuration ───
    const CARD_RATIO   = 3.5 / 2;      // EXACT 3.5 in ÷ 2 in = 1.75
    const MIN_COVER    = 0.75;         // require ≥75% coverage to consider a rectangle valid
    const OCR_PATTERN  = /SKINTELLI/i; // match “SKINTELLI”
    const OCR_DEBOUNCE = 800;          // milliseconds between OCR runs
    const OUTPUT_W     = 1280;         // final JPEG width; height = OUTPUT_W / 1.75

    // ─── DOM References ───
    const wrapper   = document.getElementById('wrapper');
    const videoEl   = document.getElementById('video');
    const msg       = document.getElementById('msg');
    const hint      = document.getElementById('hint');
    const shutter   = document.getElementById('shutter');
    const fatal     = document.getElementById('fatal');
    const preview   = document.getElementById('preview');
    const captured  = document.getElementById('captured');
    const download  = document.getElementById('download');
    const retake    = document.getElementById('retake');
    const guideBox  = document.getElementById('guide');
    const cornerTL  = document.getElementById('corner_tl');
    const cornerTR  = document.getElementById('corner_tr');
    const cornerBL  = document.getElementById('corner_bl');
    const cornerBR  = document.getElementById('corner_br');

    // ─── State Variables ───
    let cardDetected    = false;
    let lastOCRTime     = 0;
    let tesseractWorker = null;
    // Offscreen <canvas> for native‐pixel processing (video’s full resolution)
    const offscreen = document.createElement('canvas');

    // ─── Size & Center the Guide Box, and Position its Four Corners ───
    function sizeGuide() {
      // 84% of viewport width
      const vw = window.innerWidth;
      const guideW = vw * 0.84;
      // Height to preserve CARD_RATIO (1.75)
      const guideH = guideW / CARD_RATIO;

      // Apply CSS dimensions to #guide:
      guideBox.style.width  = `${guideW}px`;
      guideBox.style.height = `${guideH}px`;
      guideBox.style.left   = `50%`;
      guideBox.style.top    = `50%`;
      guideBox.style.transform = `translate(-50%, -50%)`;

      // Make corners visible (CSS positioning now places them at the four corners)
      cornerTL.style.display = 'block';
      cornerTR.style.display = 'block';
      cornerBL.style.display = 'block';
      cornerBR.style.display = 'block';

      // Position "hint" text 20px below guide:
      const r = guideBox.getBoundingClientRect();
      hint.style.top = `${r.bottom + 20}px`;
      hint.style.left = `50%`;
      hint.style.transform = `translateX(-50%)`;
    }

    // ─── OCR helper: first try native TextDetector, then Tesseract.js ───
    async function detectTextSKINTELLI(blob) {
      if ('TextDetector' in window) {
        try {
          const detector = new TextDetector();
          const bmp      = await createImageBitmap(blob);
          const results  = await detector.detect(bmp);
          bmp.close();
          return results.some(r => OCR_PATTERN.test(r.rawValue));
        } catch (e) {
          // If native fails, fall back to Tesseract
        }
      }
      if (!tesseractWorker) {
        tesseractWorker = Tesseract.createWorker({
          logger: m => console.log(m) // optional logging
        });
        await tesseractWorker.load();
        await tesseractWorker.loadLanguage('eng');
        await tesseractWorker.initialize('eng');
      }
      const { data: { text } } = await tesseractWorker.recognize(blob);
      return OCR_PATTERN.test(text);
    }

    // ─── Called on first tap (or click) to enable the camera ───
    async function enableCamera() {
      // Remove both listeners so it only fires once:
      wrapper.removeEventListener('click', enableCamera);
      wrapper.removeEventListener('touchstart', enableCamera);

      // Hide banner immediately
      msg.style.display = 'none';

      // Request camera
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        videoEl.srcObject = stream;
        // On iOS, calling play() inside this user gesture prevents the ▶︎ icon
        await videoEl.play();
      } catch (err) {
        fatal.textContent = 'Camera error: ' + (err.message || err.name);
        fatal.style.display = 'flex';
        return;
      }

      // Wait until metadata is ready (so we know videoEl.videoWidth/videoEl.videoHeight)
      await new Promise(r => { videoEl.onloadedmetadata = r; });

      // Set offscreen canvas to the camera’s native resolution:
      offscreen.width  = videoEl.videoWidth;
      offscreen.height = videoEl.videoHeight;

      // Now size & center the guide box & corners
      sizeGuide();

      // Start the detection loop
      requestAnimationFrame(detectLoop);
    }

    // ─── Main detection loop: rect → OCR → color corners + hint → loop ───
    async function detectLoop() {
      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(videoEl, 0, 0);

      // 1) Convert #guide’s CSS coordinates → video’s native pixels
      const guideCSS = guideBox.getBoundingClientRect();
      const videoCSS = videoEl.getBoundingClientRect();
      const dispW   = videoCSS.width, dispH   = videoCSS.height;
      const natW    = videoEl.videoWidth, natH = videoEl.videoHeight;
      const scaleX = natW / dispW, scaleY = natH / dispH;

      // The top-left of #guide in native-pixel space:
      const gx = (guideCSS.left   - videoCSS.left) * scaleX;
      const gy = (guideCSS.top    - videoCSS.top)  * scaleY;
      const gw = guideCSS.width   * scaleX;
      const gh = guideCSS.height  * scaleY;

      // 2) jScanify rectangle detection on that ROI (native-pixel)
      let rectOK = false;
      try {
        const roiData = offCtx.getImageData(gx, gy, gw, gh);
        const quads   = window.jscanify.detect(roiData);
        if (quads.length) {
          const q  = quads[0];
          const bw = Math.hypot(q[1].x - q[0].x, q[1].y - q[0].y);
          const bh = Math.hypot(q[3].x - q[0].x, q[3].y - q[0].y);
          if (bw / gw >= MIN_COVER && bh / gh >= MIN_COVER) {
            rectOK = true;
          }
        }
      } catch (e) {
        rectOK = false;
      }

      // 3) If rectangle found, run OCR (debounced)
      let ocrOK = false;
      const now = Date.now();
      if (rectOK && now - lastOCRTime > OCR_DEBOUNCE) {
        lastOCRTime = now;
        const blob = await new Promise(cb => offscreen.toBlob(cb, 'image/jpeg', 0.6));
        ocrOK = await detectTextSKINTELLI(blob);
      }

      // 4) True cardDetected only if both rectOK & ocrOK
      cardDetected = rectOK && ocrOK;

      // 5) Toggle “ready” on all four corners
      [cornerTL, cornerTR, cornerBL, cornerBR].forEach(el => {
        if (cardDetected) el.classList.add('ready');
        else             el.classList.remove('ready');
      });

      // 6) Update hint text 20px below the guide
      hint.textContent = cardDetected
        ? 'Hold steady and press shutter'
        : rectOK
          ? 'Reading card…'
          : 'Move card fully inside corners';

      // 7) Color the shutter’s inner circle when ready
      shutter.classList.toggle('ready', cardDetected);

      // 8) Repeat
      requestAnimationFrame(detectLoop);
    }

    // ─── Shutter: crop if cardDetected; else full frame ───
    shutter.addEventListener('click', () => {
      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(videoEl, 0, 0);

      // Convert #guide CSS → native pixels again
      const guideCSS = guideBox.getBoundingClientRect();
      const videoCSS = videoEl.getBoundingClientRect();
      const dispW = videoCSS.width, dispH = videoCSS.height;
      const natW = videoEl.videoWidth, natH = videoEl.videoHeight;
      const scaleX = natW / dispW, scaleY = natH / dispH;

      const gx = (guideCSS.left - videoCSS.left) * scaleX;
      const gy = (guideCSS.top  - videoCSS.top)  * scaleY;
      const gw = guideCSS.width * scaleX;
      const gh = guideCSS.height * scaleY;

      const outCanvas = document.createElement('canvas');
      if (cardDetected) {
        // Crop → scale to 1280 × (1280 / 1.75)
        outCanvas.width  = OUTPUT_W;
        outCanvas.height = Math.round(OUTPUT_W / CARD_RATIO);
        const outCtx = outCanvas.getContext('2d');
        outCtx.drawImage(
          offscreen,
          gx, gy, gw, gh,
          0, 0,
          outCanvas.width, outCanvas.height
        );
      } else {
        // No cardDetected: capture full frame (native resolution)
        outCanvas.width  = offscreen.width;
        outCanvas.height = offscreen.height;
        const outCtx = outCanvas.getContext('2d');
        outCtx.drawImage(offscreen, 0, 0);
      }

      const jpegUrl = outCanvas.toDataURL('image/jpeg', 0.9);
      wrapper.style.display = 'none';
      preview.style.display = 'flex';
      captured.src = jpegUrl;

      download.onclick = () => {
        const a = document.createElement('a');
        a.href = jpegUrl;
        a.download = cardDetected ? 'skintelli_card.jpg' : 'full_frame.jpg';
        a.click();
      };
      retake.onclick = () => {
        preview.style.display = 'none';
        wrapper.style.display = 'block';
        cardDetected = false;
        hint.textContent = '';
      };
    });

    // ─── Bind first “touchstart” / “click” to enableCamera ───
    wrapper.addEventListener('touchstart', enableCamera, { once: true });
    wrapper.addEventListener('click',      enableCamera, { once: true });

    // ─── On window resize, re‐size the guide immediately (if camera is active) ───
    window.addEventListener('resize', () => {
      if (!videoEl.paused && !videoEl.ended) {
        sizeGuide();
      }
    });

    // ─── Immediately draw the guide in the center (before camera starts) ───
    // This makes it visible even on desktop or before tapping.
    document.addEventListener('DOMContentLoaded', () => {
      sizeGuide();
    });
  </script>
</body>
</html>
